

datasource db {
  provider = "postgresql"
}

// Define custom output path for generated Prisma Client

generator client {
  provider = "prisma-client"
   output   = "../src/lib/server/db/generated/prisma"
}

/* =================================
   USER MODEL (Doctors + Owners)
   ================================= */
model User {
  id              String   @id @default(cuid())
  nameAr          String
  nameEn          String
  specialization  String?
  phoneNumber     String   @unique
  passwordHash    String
  userAuthToken   String   @unique
  createdPatients  Patient[] @relation("PatientCreator")
  // Clinic owner relation (optional, one-to-one)
  ownedClinic     Clinic?  @relation("ClinicOwner")
  

  // Medical center doctor relation (optional)
  medicalCenterId String?
  medicalCenter   MedicalCenter? @relation("MedicalCenterDoctors", fields: [medicalCenterId], references: [id])

  // Medical center owner relation (optional)
  ownedMedicalCenter MedicalCenter? @relation("MedicalCenterOwner")

  isOwner         Boolean @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  role   Role @relation(fields: [roleId], references: [id])
  roleId Int
  status       SubscriptionStatus @default(PENDING) // current state

   
  @@index([medicalCenterId])           // For join to MedicalCenter
  @@index([roleId])                     // For join to Role
  @@index([isOwner])                    // For owner filtering
  @@index([status])                     // For subscription filtering
  @@index([isOwner, medicalCenterId])   // Composite for doctor type detection
}

/* 
============================
CLINIC (Single Doctor Owner)
============================ 
*/

model Clinic {
  id            String   @id @default(cuid())
  clinicName    String   @unique

  ownerId       String?  @unique
  owner         User?    @relation("ClinicOwner", fields: [ownerId], references: [id])

  // NEW many-to-many relation
  patients      Patient[] @relation("PatientClinics")

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

/* ============================================
   MEDICAL CENTER (Multi-Doctor + Owner)
   ============================================ */
model MedicalCenter {
  id             String  @id @default(cuid())
  centerName     String

  ownerId        String? @unique
  owner          User?   @relation("MedicalCenterOwner", fields: [ownerId], references: [id])

  doctors        User[]  @relation("MedicalCenterDoctors")

  // NEW many-to-many relation
  patients       Patient[] @relation("PatientMedicalCenters")

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}



/* 
============================
ROLE (DEFINES USER ROLES(ADMIN, DOCTOR, ETC))
============================ 
*/
model Role {
  id   Int    @id @default(autoincrement())
  name String @unique
  User User[]
}


model Patient {
  id            String   @id @default(cuid())

  fullname      String
  fullnameAr    String   
  phoneNumber   String   @unique

  createdById   String
  createdBy     User     @relation("PatientCreator", fields: [createdById], references: [id])

  
  clinics        Clinic[]        @relation("PatientClinics")
  medicalCenters MedicalCenter[] @relation("PatientMedicalCenters")

  createdAt       DateTime        @default(now())
  updated         DateTime        @updatedAt

  @@index([phoneNumber])
}

/* =================================
   TREATMENT CATALOG & GROUPS
   ================================= */

model TreatmentGroup {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "Tooth Gum", "Surgery"
  nameAr      String?  // Optional Arabic name for consistency with User model
  color       String   // e.g., "#FFC0CB" or "Pink"
  
  // Relation: A group contains many treatments
  treatments  Treatment[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Treatment {
  id          String   @id @default(cuid())
  name        String   // e.g., "Gingivectomy", "Deep Cleaning"
  nameAr      String?  
  
  // Relation to Group
  groupId     String
  group       TreatmentGroup @relation(fields: [groupId], references: [id])

  // Optional: Base price (can be overridden by clinics later)
  basePrice   Decimal? @default(0.0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([groupId]) // Optimization for fetching treatments by group
}

enum SubscriptionStatus {
  PENDING
  SUCCESS
  CANCELLED
}